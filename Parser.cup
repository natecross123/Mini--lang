import java_cup.runtime.*;
import java.io.*;
import java.util.*;

/* Preliminaries to set up and use the scanner.  */
parser code {:
		Lexer lexer;

		public ArithParser(Lexer l) {
		    // As of CUP v0.11, need to pass Lexer to superclass
		    super(l);
		    lexer = l;
		}

		public void report_error(String message, Object info) {
		    System.err.println(message);
		}

		public void syntax_error(Symbol cur_token) {
		    System.err.print("Line " + lexer.getLine() +
				     " near char " + lexer.getChar() + ": ");
		    report_error("Syntax error", cur_token);
		    System.err.println ("Last token read is " +
					 lexer.getText());
		}
	    :};

init with {:
	  :};

scan with {:
		try {
		    return lexer.next_token();
		} catch (java.io.IOException ioe) {
		    System.out.println("Line " + lexer.getLine() + ", pos " +
				       lexer.getChar() +
				       ": Unrecognised token");
		    System.out.println(ioe.getMessage());
		    throw ioe;
		}
	  :};

/* Terminals (tokens returned by the scanner). */
// keywords
terminal FUN, IF, ELIF, ELSE, END;

// special symbols
terminal LPAREN, RPAREN, SEMI, COLON;
terminal LBRACE, RBRACE, COMMA, EQUAL;

// arithmetic operators
terminal PLUS, MINUS, MUL, DIV, MOD, ASSIGN;

// comparison operators
terminal Cmp COMPARISON;

// terminals with values
terminal Integer INT;
terminal String VAR;

/* Non terminals */
non terminal ArithProgram program;
non terminal StmtSequence stmtList;
non terminal Statement stmt;
non terminal StmtDefinition definition;

non terminal StmtFunDefn funDefn;
non terminal ArrayList<String> paramList;
non terminal ArrayList<String> paramListE;

non terminal ArrayList<Exp> argList;
non terminal ArrayList<Exp> argListE;

non terminal Exp expression;
non terminal Exp term;
non terminal Exp factor;

non terminal Exp logicalExpr;
non terminal ExpIf ifExpr;
non terminal ArrayList<ConditionalClause> elifClauses;
non terminal ArrayList<ConditionalClause> elifClausesOpt;
non terminal ConditionalClause conditionalClause;
non terminal Exp elseClauseOpt;

non terminal empty;

/* Grammar rules */

program ::= stmtList:s {: RESULT = new ArithProgram(s); :};

stmtList ::= stmtList:lst stmt:s {:
		lst.add(s); 
		RESULT = lst;
		:} |
	     stmt:s {:
		RESULT = new StmtSequence(s);
		:};

stmt ::= definition:d {: RESULT = d; :} |
	 funDefn:f {: RESULT = f; :} |
	 expression:e SEMI {: RESULT = new Statement(e); :};

/* Function definitions */
funDefn ::= FUN VAR:name LPAREN paramListE:params RPAREN EQUAL expression:body SEMI {:
		RESULT = new StmtFunDefn(name, params, body);
	    :} |
	    FUN VAR:name LPAREN paramListE:params RPAREN LBRACE stmtList:body RBRACE {:
		RESULT = new StmtFunDefn(name, params, body);
	    :};

paramList ::= VAR:id {:
		ArrayList<String> lst = new ArrayList<>();
		lst.add(id);
		RESULT = lst;
	    :} |
	    paramList:lst COMMA VAR:id {:
		lst.add(id);
		RESULT = lst;
	    :};

paramListE ::= paramList:lst {: RESULT = lst; :} |
	       empty {: RESULT = new ArrayList<String>(); :};

/* Variable definitions */
definition ::= VAR:v ASSIGN expression:e SEMI {:
		   RESULT = new StmtDefinition(v, e);
		:};

/* Expressions */
expression ::= 	expression:e PLUS term:t {:
			RESULT = new ExpAdd(e, t); :} |
		expression:e MINUS term:t {:
			RESULT = new ExpSub(e, t); :} |
		term:t {: RESULT = t; :} |
		ifExpr:i {: RESULT = i; :};

term ::= term:t MUL factor:f {:
		RESULT = new ExpMul(t, f); :} |
	 term:t DIV factor:f {:
		RESULT = new ExpDiv(t, f); :} |
	 term:t MOD factor:f {:
		RESULT = new ExpMod(t, f); :} |
	 factor:f {: RESULT = f; :};

factor ::= INT:ilit {: RESULT = new ExpLit(ilit); :} |
	   VAR:var LPAREN argListE:args RPAREN {: 
	       RESULT = new ExpFunCall(var, args); :} |
	   VAR:var {: RESULT = new ExpVar(var); :} |
	   LPAREN expression:e RPAREN {: RESULT = e; :};

/* Function call arguments */
argList ::= expression:e {:
		ArrayList<Exp> lst = new ArrayList<>();
		lst.add(e);
		RESULT = lst;
	    :} |
	    argList:lst COMMA expression:e {:
		lst.add(e);
		RESULT = lst;
	    :};

argListE ::= argList:lst {: RESULT = lst; :} |
	     empty {: RESULT = new ArrayList<Exp>(); :};

/* Logical expressions */
logicalExpr ::= expression:e1 COMPARISON:cmp expression:e2 {:
		    RESULT = new ExpComparison(cmp, e1, e2);
		:} |
		expression:e1 EQUAL expression:e2 {:
		    RESULT = new ExpComparison(Cmp.EQ, e1, e2);
		:};

/* If expressions */
ifExpr ::= IF logicalExpr:pred COLON expression:cons elifClausesOpt:elifs elseClauseOpt:alt END {:
	       RESULT = new ExpIf(pred, cons, elifs, alt);
	   :};

elifClausesOpt ::= elifClauses:lst {: RESULT = lst; :} |
		   empty {: RESULT = new ArrayList<ConditionalClause>(); :};

elifClauses ::= elifClauses:lst conditionalClause:c {:
		    lst.add(c);
		    RESULT = lst;
		:} |
		conditionalClause:c {:
		    ArrayList<ConditionalClause> lst = new ArrayList<>();
		    lst.add(c);
		    RESULT = lst;
		:};

conditionalClause ::= ELIF logicalExpr:pred COLON expression:cons {:
			  RESULT = new ConditionalClause(pred, cons);
		      :};

elseClauseOpt ::= ELSE expression:e {: RESULT = e; :} |
		  empty {: RESULT = null; :};

empty ::= ;